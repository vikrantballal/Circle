Practical 5

A):-Monkey Banana Problem

code:

class State:
    def __init__(self, monkey, box, banana):
        self.monkey = monkey
        self.box = box
        self.banana = banana
        
    def __str__(self):
        return f"Monkey: {self.monkey}, Box: {self.box}, Banana: {self.banana}"
def push_box(state):
      if not state.box and not state.monkey:
         return State(state.monkey, True, state.banana)
      return state
def climb_box(state):
    if state.box and not state.monkey:
        # monkey climbs box and can reach banana
        return State(True, state.box, True)
    return state
def grab_banana(state):
    if state.monkey and state.banana:
        print("Banana grabbed!")
        return State(state.monkey, state.box, True)
    return state
def grab_banana(state):
    if state.monkey and state.banana:
        print("Banana grabbed!")
        return State(state.monkey, state.box, True)
    return stste
def monkey_banana_problem():
    initial_state = State(False, False, False)
    print("Initial State:", initial_state)


    state = push_box(initial_state)
    print("After pushing the box:", state)
    state = climb_box(state)
    print("After climbing the box:",state)
    state = grab_banana(state)
if __name__ ==  "__main__":
    monkey_banana_problem()



b) Missionaries-Cannibals Problems

Code:

from collections import deque


def is_valid(m, c):
    # Check bounds
    if m < 0 or c < 0 or m > 3 or c > 3:
        return False
    # Left bank: missionaries can't be outnumbered by cannibals (unless missionaries == 0)
    if m != 0 and m < c:
        return False
    # Right bank: same check for the other side
    if (3 - m) != 0 and (3 - m) < (3 - c):
        return False
    return True


def missionaries_cannibals():
    start = (3, 3, 1)  # (missionaries_left, cannibals_left, boat_pos)
    goal = (0, 0, 0)
    queue = deque([(start, [])])
    visited = set()


    while queue:
        state, path = queue.popleft()
        if state in visited:
            continue
        visited.add(state)


        m, c, b = state
        if state == goal:
            return path + [state]


        moves = [(1, 0), (2, 0), (0, 1), (0, 2), (1, 1)]
        for dm, dc in moves:
            if b == 1:  # boat on left bank
                new_state = (m - dm, c - dc, 0)
            else:  # boat on right bank
                new_state = (m + dm, c + dc, 1)


            if is_valid(new_state[0], new_state[1]):
                queue.append((new_state, path + [state]))


solution = missionaries_cannibals()
for s in solution:
    print(s)



